【1】线程



task_struct  结构体
操作为每一个进程分配地址空间


线程   操作系统会为每一个线程task_struct  结构体，但是不会为你分配地址空间
      在原有进程中去使用，所有在当前进程中创建的线程会共享进程的地址空间
      
      
      同时执行多个程序，减少了系统切换时所需要的开销
      线程依附于进程，当一个进程结束的时候，线程也就结束了，不要使用进程中的
      exit函数
      在系统当中线程的实现，用函数来实现，线程的通信是通过全局变量来实现的
-----------------------------------------------------------------------------      
      int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg);

       Compile and link with -pthread.编译或者连接时要加上-pthread
      功能：  线程的创建函数，在一个进程中创建一个线程
      参数：
            pthread  线程标识符，唯一的表示一个线程
            attr     线程的属性，默认分配的地址空间，8M大小
            start_routine  函数指针，把一个函数名传递给start_routine，函数的类型
                    必须跟start_routine形参 和返回值保持一致
                    
            arg     传递给start_routine的第三个参数的形参
       返回值： 
            成功  0   把0作为一个判断条件
            失败  错误码
            
       int pthread_join(pthread_t thread, void **retval);
       功能：  线程结束时的处理函数，当一个线程结束时，需要清理task_struct结构体
       参数：  pthread   指定哪一个线程
                retval   接受pthread_exit函数的形参
                
       
       int pthread_exit(void*)
       功能： 线程结束函数，只能在线程中去调用
       
    ---------------------------------------------------------------------
    信号量   代表着某一种资源，这种资源有一定的数量，用一个变量的形式，代表某一类
            资源，需要设置一个这个资源的数量  数量的值是大于等于0的值
            
            
            实现同步操作，
            同步操作：把一个任务分成了多份，按照约定的先后顺序，共同去完成一件事情
            
            术语：
                共享资源：   可以被一个或者多个任务（进程和线程）同时访问的资源
                临界资源：   可以被一个或者多个任务（进程和线程）不能同时访问的资源
                临界区：     在程序当中可以被线程或者进程访问临界资源的那一段代码
PV操作：
            申请操作  （P） 
            
                在一个进程或者线程对资源进行的申请操作，如果资源的数量等于0，申请
                在调用申请的那个操作就会处于阻塞的状态
                如果资源有一定数量，执行一次申请操作，可以申请到，并会让资源的数量
                进行减 1 操作
            
            
            释放操作   （V）
       
                在没有线程申请的前提下，释放一次，让资源的数量在原有值得基础之上加 1   
                有线程在进行资源的申请操作，释放一次，让资源的数量保持原有数值
       
       
            1、信号量的初始化操作
                sem_init
                 int sem_init(sem_t *sem, int pshared, unsigned int value);
                  功能：  创建信号量（资源）
                  参数：
                       sem      代表一个信号量（资源）
                       pshared  来设置实在进程间使用信号量还是进程中的线程间使用信号量
                                当这个指定为0时候，线程之间共享
                                如果是  非0  值，则是进程间共享
                       value    代表的是资源的数量是多少个？
                       
            2、信号量的申请或者释放操作
                sem_wait  (申请)   sem_post (释放)
                int  sem_wait(sem_t *sem)
                
                功能：  申请一个信号量资源，让他的数值减 1
                参数： sem   是由sem_init初始化的那个信号量
                返回值： 
                      成功  0
                      失败  -1
                      
                int  sem_post(sem_t *sem)
                
                功能：  释放一个信号量资源，让他的数值加减 1
                参数： sem   是由sem_init初始化的那个信号量
                返回值： 
                      成功  0
                      失败  -1                      
   ---------------------------------------------------------------
   互斥：解决资源独占的问题，把用户的临界区整个执行完毕之后，再去执行其他的线程             
          一个线程在访问的时候，另外一个线程不能再去访问共享资源
          
    互斥(mutual exclusion)锁的目的是用来保证共享数据操作的完整性   
       
       互斥锁用来保护临界资源，当一个线程有上锁和解锁两种操作方式
       当前线程想要保护临界资源申请到锁之后，其他的线程也想要申请这把锁，那其他的从
       线程就会处于阻塞状态，只有当其他的线程八所释放掉之后，才有可能区获取的锁，进行加锁
       操作
       
       并不能实现同步问题，所以在使用完互斥锁还需要跟条件变量配合使用，完成同步问题
       
       
       int pthread_mutex_init(pthread_mutex_t * mutex, attr)
       
       功能：  创建一把互斥锁，这把锁默认属性是在一个进程中使用，默认传递属性NULL
       参数：
            mutex   代表互斥锁
            attr    锁的属性变量（默认属性）
       返回值：  
            成功  0
            失败  错误码
            
       int pthread_mutex_detroy(pthread_mutex_t * mutex)
       功能：  把 pthread_mutex_init  创建的那把锁销毁掉


       
       int pthread_mutex_lock(pthread_mutex_t * mutex)
       功能：  对临界区进行上锁（加锁操作）
       
       int pthread_mutex_unlock(pthread_mutex_t * mutex)
       功能：  对临界区进行解锁（释放锁操作） 
       
       
       
       条件变量：
       
       当条件满足的时候才会执行释放（函数立即返回），如果条件不满足，则会一直
       等待条件满足，一个线程需要向另一个等待条件变量的线程发送信号（条件）。      
       
           不能单独使用。必须配合互斥锁使用，完成同步问题
           
           
       int pthread_cond_wait(pthread_cond_t *restrict cond,
              pthread_mutex_t *restrict mutex);
              
              
       功能：  等待条件变量满足的函数，如果不满足，则会阻塞
                                       如果满足，函数立即返回
                                       
               这个函数的执行过程是 解锁  - 判断条件是否满足 - 上锁操作                        
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――                                    
【3】    进程间通信

早期通信机制：  无名管道   有名管道   信号


贝尔实验室研究的几种通信方式：  共享内存  信号量集   消息队列
前面六中属于在一台电脑当中实现进程通信


套接字通信


方式：  数据传输操作 、  进程信号的通知


【无名管道】  
    是内存当中一块缓冲区，大小是64k
    特点：  
        不同进程之间无法使用无名管道，在你的当前系统找不到跟内存区域对应的文件，
        对你的无名进行打开读写操作
       只能在父子进程兄弟进程或者子孙进程实现通信
       单向的传输方式
       
      pipe
      
      int   pipe(int pipefd[2])
      功能：创建一个无名管道
      参数 
          pipefd[0]   代表管道的读端，也就从管道中读数据  read
          pipefd[1]   代表管道的写端，也就往管道中写数据  write
          
       write写满64k，写操作就会阻塞，只有读取才会解除阻塞，读取数据必须要求管道
       大于4k;   
       如果只关闭读端，在写的话管道会破裂，进程会终止；如果只关闭写端，读端正常且不阻塞；
       如果谁都不关闭，管道空，不往里写，这时读的时候读端会阻塞等待。
          
作业：在一个进程中用管道读取文件，再用另一个亲属进程把管道中的内容写到另一个文件中
          
          
      
      







































      
           
           
           
           
           
           
           
           
           
           
           
            
            
            
            
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
             
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
      
      
      
      
      
      
      
      
      
      
      
      
      
      